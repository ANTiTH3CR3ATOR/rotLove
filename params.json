{"name":"Rotlove","tagline":"Love2D port of rot.js","body":"rotLove is mostly a direct port of rot.js. I love roguelikes and love2D, and (being a beginner struggling to break in to intermediacy) I thought it would be fun to create something that duplicated the functionality found in libtcod and rot.js.\r\n\r\nFollowing are some simple examples of a few of the classes available with rotLove. I'll be adding more here as I get time, but for now I've included a [demos branch](https://github.com/paulofmandown/rotLove/tree/demos) that has examples for every bit of functionality offered.\r\n\r\nDisplay\r\n=========\r\nDisplay started out as rlLove, which itself was a port of [Trystan Spangler's](https://github.com/trystan/) Java-based [Ascii Panel](https://github.com/trystan/AsciiPanel) to Love2D.\r\n\r\nIt is not as robust as rot.js' Display feature, in that is effectively a code page 437 ASCII terminal emulator.\r\n\r\n```lua\r\nROT = require 'vendor/rotLove/rot'\r\nfunction love.load()\r\n  -- create a display object with the following.\r\n    -- Display(widthInCharacters(80), heightInCharacters(24), characterScale(1)\r\n    --         defaultForegroundColor({r=235, g=235, b=235, a=255}),\r\n    --         defaultBackgroundColor({r=15 , g=15 , b=15 , a=255}),\r\n    --         useFullScreen, useVSync, numberOfFsaaSamples (false, false, 0))\r\n    display=ROT.Display:new()\r\n  -- and write some things out.\r\n    local x_position=1\r\n    local y_position=1\r\n    display:write('some string or character', x_position, y_position)\r\n  \r\n  -- or write something to the center\r\n    y_position=5\r\n    display:writeCenter('another string/character', y_position)\r\n    \r\n  -- you can clear the display with:\r\n  -- display:clear()\r\n  \r\n  -- and you can specify an area to clear with:\r\n  -- display:clear(char, x_position, y_position, width, height)\r\n    -- defaults are: ' ', 1, 1, displayWidthInChars, displayHeightInChars\r\nend\r\nfunction love.draw()\r\n    display:draw()\r\nend\r\nfunction love.update() end\r\n```\r\n\r\nString Generator\r\n=========\r\nThe string generator can be given words to learn from, and then provide you with randomly generated words based on what it has learned.\r\n```lua\r\nROT = require 'vendor/rotLove/rot'\r\nfunction love.load()\r\n    -- make your display\r\n    frame=ROT.Display:new()\r\n    \r\n    -- now make your string generator\r\n    sg = ROT.StringGenerator:new()\r\n    \r\n    -- read in your names.\r\n    -- where names.txt is a plain-text list of mixed-case names (one per line)\r\n    for name in io.lines('names.txt') do\r\n        -- .observe(string) reads a string and learns from it.\r\n        sg:observe(name)\r\n    end\r\n    \r\n    -- .getStats() will tell you how many distinct characters your string gen will use\r\n                              -- how many different contexts it has seen\r\n                                 -- (i.e.: the context of the letter 'n' in seen is 'see')\r\n                              -- and how many words your string gen has seen\r\n    frame:writeCenter(sg:getStats(), 1)\r\n    \r\n    for i=2,24 do\r\n        -- .generate() will return a random string weighted on the words it has seen with .observe()\r\n        local name = sg:generate()\r\n        frame:writeCenter(name, i)\r\n    end\r\nend\r\nfunction love.update() end\r\nfunction love.draw() frame:draw() end\r\n```\r\n\r\nEventQueue\r\n=========\r\nThe event queue is the base element of all of the schedulers. It can receive any object and feed it back to you when it's turn comes up.\r\n```lua\r\nROT= require 'vendor/rotLove/rot'\r\nfunction love.load()\r\n    f=ROT.Display:new()\r\n    -- create the event queue\r\n    q=ROT.EventQueue:new()\r\n    -- use add(object, timeToTurn) to add events\r\n    q:add('e1', 100)\r\n    q:add('e2', 50)\r\n    q:add('e3', 10)\r\n    \r\n    -- remove(object) will remove the next instance of the provided object from the queue\r\n    q:remove('e2')\r\n    \r\n    -- get() returns the next object from the queue\r\n    f:writeCenter(tostring(q:get()), 11)\r\n    f:writeCenter(tostring(q:get()), 12)\r\n    \r\n    -- getTime() returns the number of time units that have passed since the queue was initiated\r\n    f:writeCenter(tostring(q:getTime()), 13)\r\nend\r\nfunction love.draw() f:draw() end\r\n```\r\n\r\nSimple Scheduler\r\n=========\r\nSimple scheduler is a turn scheduler that takes in objects and returns them in order. It has an additional parameter for repeating events.\r\n\r\n```lua\r\nROT= require 'vendor/rotLove/rot'\r\nfunction love.load()\r\n    f=ROT.Display:new()\r\n    s=ROT.Scheduler.Simple:new()\r\n    -- use add to add objects. the second argument (if true) will tell the scheduler to re-insert the event after every turn it gets.\r\n    for i=1,3 do s:add(i, true) end\r\nend\r\nfunction love.update()\r\n    love.timer.sleep(.5)\r\n    -- use next() to get the next event\r\n    f:writeCenter('TURN: '..s:next())\r\nend\r\nfunction love.draw() f:draw() end\r\n```\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}